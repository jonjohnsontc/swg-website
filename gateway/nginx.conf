# Literally copied this all from conan

# root nginx.conf
user  nginx;
worker_processes  auto;

error_log  /var/log/nginx/error.log notice;
pid        /var/run/nginx.pid;

load_module /etc/nginx/modules/ngx_http_js_module.so;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;

    keepalive_timeout  65;

    include /etc/nginx/api_gateway.conf; # All API gateway configuration
    include /etc/nginx/conf.d/*.conf;    # Regular web traffic
}

# api_backends.conf
# The keepalives should help with 504 timeouts hopefully.  also note in the server config
# I added in the http version and proxy_set_header connection for this to work

upstream nautilus_api_main {
    keepalive 32;
    zone nautilus_service 64k;
    server nautilus:5000;
}

upstream nap_frontend_app_main {
    keepalive 32;
    zone nap_frontend_app_service 64k;
    server nap-frontend:80;
}

# api_gateway.conf
log_format api_main '$remote_addr - $remote_user [$time_local] "$request"'
                    '$status $body_bytes_sent "$http_referer" "$http_user_agent"'
                    '"$http_x_forwarded_for" "$api_name"';

include api_backends.conf;

server {
    set $api_name -; # Start with an undefined API name, each API will update this value
    
    access_log /var/log/nginx/api_access.log api_main; # Each API may also log to a separate file
    error_log /dev/stdout info;
    
    root /etc/nginx/html;
    
    listen 80 default_server;

    index index.html index.htm index.nginx-debian.html;

    server_name _;

    location / {
        try_files $uri $uri/ =404;
    }

    # API definitions, one per file
    include api_conf.d/*.conf;

    # Error responses
    error_page 404 = @400;         # Invalid paths are treated as bad requests
    proxy_intercept_errors on;     # Do not send backend errors to the client
    include api_json_errors.conf;  # API client friendly JSON error responses
    default_type application/json; # If no content-type then assume JSON

    # In order for keepalive to work properly these must be added
    # This should help with 504 timeouts I hope (at least according to the internet it might help)
    proxy_http_version 1.1;
    proxy_set_header Connection "";


}

# api_json_errors.conf
error_page 400 = @400;
location @400 { return 400 '{"status":400,"message":"Bad request"}\n'; }

error_page 401 = @401;
location @401 { return 401 '{"status":401,"message":"Unauthorized"}\n'; }

error_page 403 = @403;
location @403 { return 403 '{"status":403,"message":"Forbidden"}\n'; }

error_page 404 = @404;
location @404 { return 404 '{"status":404,"message":"Resource not found"}\n'; }

error_page 405 = @405;
location @405 { return 405 '{"status":405,"message":"Method not allowed"}\n'; }

error_page 408 = @408;
location @408 { return 408 '{"status":408,"message":"Request timeout"}\n'; }

error_page 413 = @413;
location @413 { return 413 '{"status":413,"message":"Payload too large"}\n'; }

error_page 414 = @414;
location @414 { return 414 '{"status":414,"message":"Request URI too large"}\n'; }

error_page 415 = @415;
location @415 { return 415 '{"status":415,"message":"Unsupported media type"}\n'; }

error_page 426 = @426;
location @426 { return 426 '{"status":426,"message":"HTTP request was sent to HTTPS port"}\n'; }

error_page 429 = @429;
location @429 { return 429 '{"status":429,"message":"API rate limit exceeded"}\n'; }

error_page 495 = @495;
location @495 { return 495 '{"status":495,"message":"Client certificate authentication error"}\n'; }

error_page 496 = @496;
location @496 { return 496 '{"status":496,"message":"Client certificate not presented"}\n'; }

error_page 497 = @497;
location @497 { return 497 '{"status":497,"message":"HTTP request was sent to mutual TLS port"}\n'; }

error_page 500 = @500;
location @500 { return 500 '{"status":500,"message":"Server error"}\n'; }

error_page 501 = @501;
location @501 { return 501 '{"status":501,"message":"Not implemented"}\n'; }

error_page 502 = @502;
location @502 { return 502 '{"status":502,"message":"Bad gateway"}\n'; }


# api_keys.conf
map $http_apikey $api_client_name {
    default "";

    # API keys for default setup
    
    # TODO only adding unauth client until we have some auth around our stuff. remove
    # this once we have maf or something similar handling auth
    "" "client_unauthed"
    "7B5zIqmRGXmrJTFmKa99vcit" "client_one";
    "QzVV6y1EmQFbbxOfRCwyJs35" "client_two";
    "mGcjH8Fv6U9y3BVF9H3Ypb9T" "client_six";
}
# Testing the API needs to include an API key
#Ex: curl --header "apikey: 7B5zIqmRGXmrJTFmKa99vcit" <api url>

# nap_frontend.conf
location /nap/app {
    set $upstream nap_frontend_app_main;
    rewrite ^/nap/app(.*)$ /_nap_frontend_app_service$1 last;
}

# Policy section
#
location /_nap_frontend_app_service {
    internal;
    set $api_name "Frontend API";

    rewrite ^/_nap_frontend_app_service(.*)$ $1 break; 
    proxy_pass http://$upstream;      # Proxy the rewritten URI
}

# nautilus_api.conf
# API definition
#
location /api/conan/nautilus {
    set $upstream nautilus_api_main;
    rewrite ^/api/conan/nautilus/(.*)$ /_nautilus_service$1 last;
}

# This is used when app is running through MAF
location /conan/nautilus {
   set $upstream nautilus_api_main;
   rewrite ^/conan/nautilus/(.*)$ /_nautilus_service$1 last;
}


# Policy section
location /_nautilus_service {
    internal;
    set $api_name "nautilus backend API";

    rewrite ^/_nautilus_service(.*)$ $1 break; # Remove /_nautilus_service prefix
    proxy_pass http://$upstream;      # Proxy the rewritten URI
}
